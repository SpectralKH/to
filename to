#! /bin/bash

color() {
    echo -n "`tput setaf $1`${@:2}"
    # reset color if there are arguments:
    if [[ "$#" > 1 ]]; then echo -n "`tput setaf 7`"; fi
}
red() { color 1 "$@"; }
green() { color 2 "$@"; }
yellow() { color 3 "$@"; }
cyan() { color 6 "$@"; }
reset() { color 7 "$@"; }

help() {
    echo "
    `green Usage:`
        `cyan $FILENAME` <format> [options] <file1> [file2...]

    `green Options:`
        `cyan format`           Format to convert to.
        `cyan --formats`        List all supported formats.
        `cyan -v, --verbose`    If you love logs.
        `cyan -h, --help`       Show this help message.

        Video/audio formats support FFmpeg options (see `yellow $ ffmpeg -h`).
        Image formats support ImageMagick options (see `yellow $ man magick`).
        Long FFmpeg/ImageMagick arguments must have quotes (like \"-ac 128k\").
    "
}

list_formats() {
    echo "
    `green Video formats:`
        `cyan mp4`
        `cyan mov`
        `cyan webm`

    `green Audio formats:`
        `cyan mp3`          320kbps.
        `cyan wav`
        `cyan flac`
        `cyan aac`
        `cyan aiff`
        `cyan ogg`

    `green Image formats:`
        `cyan jpg`          Highest quality.
        `cyan jp2`          Highest quality.
        `cyan png`
        `cyan webp`
    "
}

FILENAME=${0##*/}
ARGS=("$@")
FORMAT="$1"
CMD=ffmpeg

# no args
if [[ "$#" < 1 ]]; then help; exit 0; fi

# parse args
for (( i=1; i <= "$#"; i++ )); do
    ARG="${!i}"
    case "$ARG" in
        -h|--help)
            HELP=true
            ;;
        --formats)
            LIST_FORMATS=true
            ;;
        -v|--verbose)
            VERBOSE=true
            ;;
        -*)
            if [[ "$ARG" == "-b:a" ]]; then
                AUDIO_BITRATE_CHANGED=true
            fi
            CUSTOM_OPTIONS=true
            OPTIONS+=("$ARG")
            ;;
        *)
            # dont save file if arg is first (aka format)
            if [[ $i == 1 ]]; then
                :
            elif [[ -f "$ARG" ]]; then # if file exists
                FILES+=("$ARG")
            else
                SKIPFILES+=("$ARG")
            fi
            ;;
    esac
done

# format
case "$FORMAT" in
    mp4|mov|webm)
        ;;
    mp3)
        if [[ $AUDIO_BITRATE_CHANGED != true ]]; then
            OPTIONS+=("-b:a", "320k")
        fi
        ;;
    wav|flac|aac|aiff|ogg)
        ;;
    jpg|png|webp)
        CMD=magick
        ;;
    '')
        NO_FORMAT=true
        ;;
    *)
        INVALID_FORMAT=true
        ;;
esac

if [[ $HELP == true ]]; then
    help; exit 0
elif [[ $LIST_FORMATS == true ]]; then
    list_formats; exit 0
elif [[ $NO_FORMAT == true ]]; then
    echo "`red Error:` No format provided"; exit 1
elif [[ $INVALID_FORMAT == true ]]; then
    echo "`red Error:` Invalid format: $FORMAT"; exit 1
elif [[ ${#SKIPFILES[@]} > 0 ]]; then
    for SKIPFILE in "${SKIPFILES[@]}"; do
        echo "`red Error:` Invalid argument or non-existant file: $SKIPFILE"
    done
    exit 1
elif [[ ${#FILES[@]} == 0 ]]; then
    echo "`red Error:` No files specified"; exit 1
fi

# verbose
if [[ $CMD == "ffmpeg" && $VERBOSE != true ]]; then
    OPTIONS+=("-loglevel")
    OPTIONS+=("warning")
elif [[ $CMD == "magick" && $VERBOSE == true ]]; then
    OPTIONS+=("-verbose")
fi

# custom options
if [[ $CUSTOM_OPTIONS == true || $VERBOSE == true ]]; then
    echo "Passing the following options to $CMD: `cyan "${OPTIONS[@]}"`"
fi

for FILE in "${FILES[@]}"; do

    # if file does not exist
    if [[ ! -f "$FILE" ]]; then
        echo "`red Error:` File no longer exists (Skipping): `cyan"$FILE"`"
        continue
    fi

    echo "Converting to $FORMAT: `cyan $FILE`"

    FILE_WITHOUT_EXT=${FILE%.*}
    NEW_FILE_TEMP="$FILE_WITHOUT_EXT CONVERTING... $((10000 + RANDOM)).$FORMAT"

    if [[ $CMD == "ffmpeg" ]]; then
        ffmpeg -i "$FILE" ${OPTIONS[@]} "$NEW_FILE_TEMP" || { echo `red Error:` Convertion failed;  exit 1; }
    else
        magick ${OPTIONS[@]} "$FILE" "$NEW_FILE_TEMP" || { echo `red Error:` Convertion failed;  exit 1; }
    fi

    COUNT=1
    NEW_FILE="$FILE_WITHOUT_EXT converted.$FORMAT"
    while [[ -f "$NEW_FILE" ]]; do
        if [[ -f "$NEW_FILE" ]]; then
            NEW_FILE="$FILE_WITHOUT_EXT converted ($COUNT).$FORMAT"
            (( COUNT++ ))
        else
            break
        fi
    done

    mv "$NEW_FILE_TEMP" "$NEW_FILE"

done
